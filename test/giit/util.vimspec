Describe giit#util
  Describe #doautocmd({name}[, {pattern})
    After
      augroup giit_test_util_doautocmd
        autocmd! *
      augroup END
      silent! unlet g:_giit_test_util_doautocmd
    End

    It calls {name} autocmd
      augroup giit_test_util_doautocmd
        autocmd! *
        autocmd BufReadPre * let g:_giit_test_util_doautocmd = 1
      augroup END
      Assert False(exists('g:_giit_test_util_doautocmd'))
      call giit#util#doautocmd('BufReadPre')
      Assert True(g:_giit_test_util_doautocmd)
    End

    It calls {name} autocmd with {pattern}
      augroup giit_test_util_doautocmd
        autocmd! *
        autocmd User giit_test_util_doautocmd let g:_giit_test_util_doautocmd = 1
      augroup END
      Assert False(exists('g:_giit_test_util_doautocmd'))
      call giit#util#doautocmd('User', 'giit_test_util_doautocmd')
      Assert True(g:_giit_test_util_doautocmd)
    End

    It does not show 'No matching autocommands' warning even the {name} autocmd is not registered
      augroup giit_test_util_doautocmd
        autocmd! *
        autocmd BufReadPre foo:* let g:_giit_test_util_doautocmd = 1
      augroup END
      " exists('#BufReadPre') returns 1 while BufReadPre foo:* is registered
      Assert True(exists('#BufReadPre'))
      " But a builtin doautocmd shows 'No matching autocommands' warning while
      " a current buffer does not match with the registered pattern.
      try
        redir => content
        doautocmd BufReadPre
      finally
        redir END
      endtry
      Assert Equals(split(content, "\n"), ['No matching autocommands'])
      " But giit#util#doautocmd does not call autocmd in this case
      try
        redir => content
        call giit#util#doautocmd('BufReadPre')
      finally
        redir END
      endtry
      Assert Equals(split(content, "\n"), [])
      " The registered autocmd should not be called
      Assert False(exists('g:_giit_test_util_doautocmd'))
    End
  End

  Describe #select()
    " TODO
  End

  Describe #syncbind()
    " TODO
  End

  Describe #all()
    It returns 1 when all items of {array} are truthy values
      Assert True(giit#util#all(['a', 1, [1], {'a': 1}]))
    End

    It returns 0 when one of item of {array} is falsy value
      Assert False(giit#util#all(['', 1, [1], {'a': 1}]))
      Assert False(giit#util#all(['a', 0, [1], {'a': 1}]))
      Assert False(giit#util#all(['a', 1, [], {'a': 1}]))
      Assert False(giit#util#all(['a', 1, [1], {}]))
    End
  End

  Describe #any()
    It returns 1 when one of item of {array} is truthy value
      Assert True(giit#util#any(['a', 0, [], {}]))
      Assert True(giit#util#any(['', 1, [], {}]))
      Assert True(giit#util#any(['', 0, [1], {}]))
      Assert True(giit#util#any(['', 0, [], {'a': 1}]))
    End

    It returns 0 when all items of {array} are falsy value
      Assert False(giit#util#any(['', 0, [], {}]))
    End
  End
End
