Describe Argument
  Before all
    let Path = vital#vital#import('System.Filepath')
    let scope = themis#helper('scope')
    let sfile = Path.realpath('autoload/vital/__giit__/Argument.vim')
  End

  Before
    let Argument = vital#giit#import('Argument')
    let sf = scope.funcs(sfile)
  End

  Describe .new()
    It returns an argument instance
      let args = Argument.new()
      Assert KeyExists(args, 'raw')
      Assert KeyExists(args, 'get')
      Assert KeyExists(args, 'set')
      Assert KeyExists(args, 'pop')
      Assert KeyExists(args, 'apply')
      Assert KeyExists(args, 'search')
      Assert KeyExists(args, 'p')
      Assert KeyExists(args.p, 'raw')
      Assert KeyExists(args.p, 'get')
      Assert KeyExists(args.p, 'set')
      Assert KeyExists(args.p, 'pop')
      Assert KeyExists(args.p, 'apply')
      Assert KeyExists(args.p, 'search')
    End

    It returns an argument instance with a specified list
      let args = Argument.new(['--foo', '--bar'])
      Assert Equals(args.raw, ['--foo', '--bar'])
    End
  End

  Describe .parse()
    It returns an argument instance from {str}
      let args = Argument.parse('--foo --bar hoge')
      Assert Equals(args.raw, [
            \ '--foo',
            \ '--bar',
            \ 'hoge',
            \])
    End
  End

  Context Instance
    Context Option
      Describe .iter()
        Before
          let args = Argument.new([
                \ 'foo/bar/hoge.txt',
                \ '--foo',
                \ '-bbar',
                \ '--bar=bar',
                \ '-f',
                \])
        End

        It returns a view for options
          Assert Equals(args.iter(), [
                \ '--foo',
                \ '-bbar',
                \ '--bar=bar',
                \ '-f',
                \])
        End
      End

      Describe .len()
        Before
          let args = Argument.new([
                \ 'foo/bar/hoge.txt',
                \ '--foo',
                \ '-bbar',
                \ '--bar=bar',
                \ '-f',
                \])
        End

        It returns the number of options
          Assert Equals(args.len(), 4)
        End
      End

      Describe .get()
        Before
          let args = Argument.new([
                \ 'foo/bar/hoge.txt',
                \ '--foo',
                \ '-bbar',
                \ '--bar=bar',
                \ '-f',
                \])
        End

        It returns value for {expr}
          Assert Equals(args.get('-f'), 1)
          Assert Equals(args.get('--foo'), 1)
          Assert Equals(args.get('-f|--foo'), 1)

          Assert Equals(args.get('-b'), 'bar')
          Assert Equals(args.get('--bar'), 'bar')
          Assert Equals(args.get('-b|--bar'), 'bar')
        End

        It returns {default} when {expr} is not found
          Assert Equals(args.get('--not-found'), 0)
          Assert Equals(args.get('--not-found', 'foo'), 'foo')
        End
      End

      Describe .set()
        It overwrites exising {expr} argument with {value}
          let args = Argument.new([
                \ '--foo',
                \ '-bbar',
                \ '--bar=bar',
                \ '-f',
                \])
          Assert Equals(args.set('-f|--foo', 'foobar'), '--foo=foobar')
          Assert Equals(args.get('-f'), 1)
          Assert Equals(args.get('--foo'), 'foobar')
          Assert Equals(args.raw, [
                \ '--foo=foobar',
                \ '-bbar',
                \ '--bar=bar',
                \ '-f',
                \])

          let args = Argument.new([
                \ '-f',
                \ '--foo',
                \ '-bbar',
                \ '--bar=bar',
                \])
          Assert Equals(args.set('-f|--foo', 'foobar'), '-ffoobar')
          Assert Equals(args.get('-f'), 'foobar')
          Assert Equals(args.get('--foo'), 1)
          Assert Equals(args.raw, [
                \ '-ffoobar',
                \ '--foo',
                \ '-bbar',
                \ '--bar=bar',
                \])
        End

        It add {expr} argument with {value}
          let args = Argument.new([
                \ '--foo',
                \ '-bbar',
                \ '--bar=bar',
                \ '-f',
                \])
          Assert Equals(args.set('-h|--hoge', 'hoge'), '--hoge=hoge')
          Assert Equals(args.get('-h'), 0)
          Assert Equals(args.get('--hoge'), 'hoge')
          Assert Equals(args.raw, [
                \ '--foo',
                \ '-bbar',
                \ '--bar=bar',
                \ '-f',
                \ '--hoge=hoge',
                \])
        End
      End

      Describe .pop()
        It returns an existing {expr} and remove
          let args = Argument.new([
                \ '--foo',
                \ '-bbar',
                \ '--bar=bar',
                \ '-f',
                \])
          Assert Equals(args.pop('-f|--foo'), 1)
          Assert Equals(args.get('-f'), 1)
          Assert Equals(args.get('--foo'), 0)
          Assert Equals(args.raw, [
                \ '-bbar',
                \ '--bar=bar',
                \ '-f',
                \])

          let args = Argument.new([
                \ '-f',
                \ '--foo',
                \ '-bbar',
                \ '--bar=bar',
                \])
          Assert Equals(args.pop('-f|--foo'), 1)
          Assert Equals(args.get('-f'), 0)
          Assert Equals(args.get('--foo'), 1)
          Assert Equals(args.raw, [
                \ '--foo',
                \ '-bbar',
                \ '--bar=bar',
                \])
        End
      End

      Describe .apply()
        It applies {fn} to {expr}
          let args = Argument.new([
                \ '--foo',
                \ '-bbar',
                \ '--bar=bar',
                \ '-f',
                \])
          Assert Equals(args.apply('-f|--foo', function('toupper')), '--FOO')
          Assert Equals(args.get('-f'), 1)
          Assert Equals(args.get('--foo'), 0)
          Assert Equals(args.get('--FOO'), 1)
          Assert Equals(args.raw, [
                \ '--FOO',
                \ '-bbar',
                \ '--bar=bar',
                \ '-f',
                \])
        End
      End

      Describe .search()
        Before
          let args = Argument.new([
                \ 'foo/bar/hoge.txt',
                \ '--foo',
                \ '-bbar',
                \ '--bar=bar',
                \ '-f',
                \])
        End

        It returns an index for {expr}
          Assert Equals(args.search('--foo'), 1)
          Assert Equals(args.search('-b'), 2)
          Assert Equals(args.search('--bar'), 3)
          Assert Equals(args.search('-f'), 4)
          Assert Equals(args.search('-f|--foo'), 1)
          Assert Equals(args.search('-b|--bar'), 2)
        End

        It returns an index for {expr} from {start}
          Assert Equals(args.search('-f|--foo', 2), 4)
          Assert Equals(args.search('-b|--bar', 3), 3)
        End

        It returns -1 if {expr} is not found
          Assert Equals(args.search('-n|--not-found'), -1)
        End
      End
    End

    Context Parameter
      Describe .p.iter()
        Before
          let args = Argument.new([
                \ '--foo',
                \ 'foo',
                \ '--bar',
                \ 'bar',
                \ '--piyo',
                \ 'piyo',
                \ '--puyo',
                \ 'puyo',
                \])
        End

        It returns a view for options
          Assert Equals(args.p.iter(), [
                \ 'foo',
                \ 'bar',
                \ 'piyo',
                \ 'puyo',
                \])
        End
      End

      Describe .p.len()
        Before
          let args = Argument.new([
                \ '--foo',
                \ 'foo',
                \ '--bar',
                \ 'bar',
                \ '--piyo',
                \ 'piyo',
                \ '--puyo',
                \ 'puyo',
                \])
        End

        It returns the number of options
          Assert Equals(args.p.len(), 4)
        End
      End

      Describe .p.get()
        Before
          let args = Argument.new([
                \ '--foo',
                \ 'foo',
                \ '--bar',
                \ 'bar',
                \ '--piyo',
                \ 'piyo',
                \ '--puyo',
                \ 'puyo',
                \])
        End

        It returns value for {n}
          Assert Equals(args.p.get(0), 'foo')
          Assert Equals(args.p.get(1), 'bar')
          Assert Equals(args.p.get(2), 'piyo')
          Assert Equals(args.p.get(3), 'puyo')
        End

        It returns {default} when {n} is out range
          Assert Equals(args.p.get(4), 0)
          Assert Equals(args.p.get(4, 'foo'), 'foo')
        End
      End

      Describe .p.set()
        It overwrites exising {n}-th parameter with {value}
          let args = Argument.new([
                \ '--foo',
                \ 'foo',
                \ '--bar',
                \ 'bar',
                \ '--piyo',
                \ 'piyo',
                \ '--puyo',
                \ 'puyo',
                \])
          Assert Equals(args.p.set(0, 'foobar'), 'foobar')
          Assert Equals(args.raw, [
                \ '--foo',
                \ 'foobar',
                \ '--bar',
                \ 'bar',
                \ '--piyo',
                \ 'piyo',
                \ '--puyo',
                \ 'puyo',
                \])
        End

        It add a parameter {value} as {n}-th parameter
          let args = Argument.new([
                \ '--foo',
                \ 'foo',
                \ '--bar',
                \ 'bar',
                \ '--piyo',
                \ 'piyo',
                \ '--puyo',
                \ 'puyo',
                \])
          Assert Equals(args.p.set(5, 'hoge'), 'hoge')
          Assert Equals(args.raw, [
                \ '--foo',
                \ 'foo',
                \ '--bar',
                \ 'bar',
                \ '--piyo',
                \ 'piyo',
                \ '--puyo',
                \ 'puyo',
                \ '',
                \ 'hoge',
                \])
          Assert Equals(args.p.set(10, 'poyo'), 'poyo')
          Assert Equals(args.raw, [
                \ '--foo',
                \ 'foo',
                \ '--bar',
                \ 'bar',
                \ '--piyo',
                \ 'piyo',
                \ '--puyo',
                \ 'puyo',
                \ '',
                \ 'hoge',
                \ '',
                \ '',
                \ '',
                \ '',
                \ 'poyo',
                \])
          Assert Equals(args.p.set(10, 'pipi'), 'pipi')
          Assert Equals(args.raw, [
                \ '--foo',
                \ 'foo',
                \ '--bar',
                \ 'bar',
                \ '--piyo',
                \ 'piyo',
                \ '--puyo',
                \ 'puyo',
                \ '',
                \ 'hoge',
                \ '',
                \ '',
                \ '',
                \ '',
                \ 'pipi',
                \])
        End
      End

      Describe .p.pop()
        It returns an existing {expr} and remove
          let args = Argument.new([
                \ '--foo',
                \ 'foo',
                \ '--bar',
                \ 'bar',
                \ '--piyo',
                \ 'piyo',
                \ '--puyo',
                \ 'puyo',
                \])
          Assert Equals(args.p.pop(0), 'foo')
          Assert Equals(args.p.pop(1), 'piyo')
          Assert Equals(args.raw, [
                \ '--foo',
                \ '--bar',
                \ 'bar',
                \ '--piyo',
                \ '--puyo',
                \ 'puyo',
                \])
        End
      End

      Describe .p.apply()
        It applies {fn} to {expr}
          let args = Argument.new([
                \ '--foo',
                \ 'foo',
                \ '--bar',
                \ 'bar',
                \ '--piyo',
                \ 'piyo',
                \ '--puyo',
                \ 'puyo',
                \])
          Assert Equals(args.p.apply(0, function('toupper')), 'FOO')
          Assert Equals(args.raw, [
                \ '--foo',
                \ 'FOO',
                \ '--bar',
                \ 'bar',
                \ '--piyo',
                \ 'piyo',
                \ '--puyo',
                \ 'puyo',
                \])
        End
      End

      Describe .p.search()
        Before
          let args = Argument.new([
                \ '--foo',
                \ 'foo',
                \ '--bar',
                \ 'bar',
                \ '--piyo',
                \ 'piyo',
                \ '--puyo',
                \ 'puyo',
                \])
        End

        It returns an index for {n}
          Assert Equals(args.p.search(0), 1)
          Assert Equals(args.p.search(1), 3)
          Assert Equals(args.p.search(2), 5)
          Assert Equals(args.p.search(3), 7)
        End

        It returns an index for {expr} from {start}
          Assert Equals(args.p.search(0, 2), 3)
          Assert Equals(args.p.search(1, 2), 5)
          Assert Equals(args.p.search(2, 2), 7)
        End

        It returns -1 if {expr} is not found
          Assert Equals(args.p.search(4), -1)
        End
      End
    End
  End

  Context Private
    Describe s:_split_args()
      It returns ['foo'] for 'foo'
        let ret = sf._split_args('foo')
        let exp = ['foo']
        Assert Equals(ret, exp)
      End
      It returns ['foo', 'bar'] for 'foo bar'
        let ret = sf._split_args('foo bar')
        let exp = ['foo', 'bar']
        Assert Equals(ret, exp)
      End
      It returns ['foo', '"bar bar"', 'hoge'] for 'foo "bar bar" hoge'
        let ret = sf._split_args('foo "bar bar" hoge')
        let exp = ['foo', '"bar bar"', 'hoge']
        Assert Equals(ret, exp)
      End
      It returns ['"foo foo"', '"bar bar"', '"hoge hoge"'] for '"foo foo" "bar bar" "hoge hoge"'
        let ret = sf._split_args('"foo foo" "bar bar" "hoge hoge"')
        let exp = ['"foo foo"', '"bar bar"', '"hoge hoge"']
        Assert Equals(ret, exp)
      End
      It returns ["foo", "'bar bar"', "hoge"] for "foo 'bar bar' hoge"
        let ret = sf._split_args("foo 'bar bar' hoge")
        let exp = ["foo", "'bar bar'", "hoge"]
        Assert Equals(ret, exp)
      End
      It returns ["'foo foo'", "'bar bar'", "'hoge hoge'"] for "'foo foo' 'bar bar' 'hoge hoge'"
        let ret = sf._split_args("'foo foo' 'bar bar' 'hoge hoge'")
        let exp = ["'foo foo'", "'bar bar'", "'hoge hoge'"]
        Assert Equals(ret, exp)
      End
      It returns ['foo="bar"', "hoge='piyo'"] for 'foo="bar" hoge=''piyo'''
        let ret = sf._split_args('foo="bar" hoge=''piyo''')
        let exp = ['foo="bar"', "hoge='piyo'"]
        Assert Equals(ret, exp)
      End
      It returns ['foo bar hoge' ] for 'foo\ bar\ hoge'
        let ret = sf._split_args('foo\ bar\ hoge')
        let exp = ['foo\ bar\ hoge']
        Assert Equals(ret, exp)
      End
      It returns ['foo bar\ ' 'hoge' ] for 'foo\ bar\  hoge'
        let ret = sf._split_args('foo\ bar\  hoge')
        let exp = ['foo\ bar\ ', 'hoge']
        Assert Equals(ret, exp)
      End
    End

    Describe s:_strip_quotes()
      It returns 'foo bar' for '"foo bar"'
        let ret = sf._strip_quotes('"foo bar"')
        let exp = 'foo bar'
        Assert Equals(ret, exp)
      End
      It returns 'foo bar' for "'foo bar'"
        let ret = sf._strip_quotes("'foo bar'")
        let exp = 'foo bar'
        Assert Equals(ret, exp)
      End
      It returns 'foo bar' for "foo bar"
        let ret = sf._strip_quotes("foo bar")
        let exp = 'foo bar'
        Assert Equals(ret, exp)
      End
    End

    Describe s:_build_pattern()
      It returns '^\%(--foobar\>\)' for '--foobar'
        let ret = sf._build_pattern('--foobar')
        Assert Equals(ret, '^\%(--foobar\>\)')
      End

      It returns '^\%(-f\)' for '-f'
        let ret = sf._build_pattern('-f')
        Assert Equals(ret, '^\%(-f\)')
      End

      It returns '^\%(-f\|--foobar\>\)' for '-f|--foobar'
        let ret = sf._build_pattern('-f|--foobar')
        Assert Equals(ret, '^\%(-f\|--foobar\>\)')
      End

      It returns '^\%(foobar\)' for 'foobar'
        let ret = sf._build_pattern('foobar')
        Assert Equals(ret, '^\%(foobar\)')
      End
    End

    Describe s:_split_option()
      It returns ['--foo', 1] for '--foo'
        Assert Equals(sf._split_option('--foo'), ['--foo', 1])
      End

      It returns ['-f', 1] for '-f'
        Assert Equals(sf._split_option('-f'), ['-f', 1])
      End

      It returns ['--foo', 'foo'] for '--foo=foo'
        Assert Equals(sf._split_option('--foo=foo'), ['--foo', 'foo'])
      End

      It returns ['-f', 'foo'] for '-ffoo'
        Assert Equals(sf._split_option('-ffoo'), ['-f', 'foo'])
      End
    End
  End
End
