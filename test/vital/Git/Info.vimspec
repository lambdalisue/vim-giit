Describe Git.Info
  Before all
    let Path = vital#vital#import('System.Filepath')
    let Git = vital#giit#import('Git')
    let GitProcess = vital#giit#import('Git.Process')

    let inside = g:giit#test#inside
    let f_inside = g:giit#test#f_inside
    let git = Git.get(inside)
  End

  Before
    let GitInfo = vital#giit#import('Git.Info')
  End

  Describe .get_repository_config()
    It returns a dictionary which represent 'config' file in '.git' directory
      let conf = GitInfo.get_repository_config(git)
      Assert Equals(conf.core.bare, 'false')
    End
  End

  Describe .get_branch_remote()
    It returns a name of remote
      let conf = GitInfo.get_repository_config(git)
      let ret = GitInfo.get_branch_remote(conf, 'master')
      Assert Equals(ret, '')

      let ret = GitInfo.get_branch_remote(conf, 'develop')
      Assert Match(ret, '\.\?')
    End
  End

  Describe .get_branch_merge()
    It returns a branch name of remote
      let conf = GitInfo.get_repository_config(git)
      let ret = GitInfo.get_branch_merge(conf, 'master')
      Assert Equals(ret, '')

      let ret = GitInfo.get_branch_merge(conf, 'develop')
      Assert Equals(ret, 'refs/heads/master')

      let ret = GitInfo.get_branch_merge(conf, 'develop', 1)
      Assert Equals(ret, 'master')
    End
  End

  Describe .get_remote_fetch()
    It returns a path of {remote}
      let conf = GitInfo.get_repository_config(git)
      let ret = GitInfo.get_remote_fetch(conf, 'external')
      Assert Equals(ret, '+refs/heads/*:refs/remotes/external/*')
    End
  End

  Describe .get_remote_url()
    It returns a URL of {remote}
      let conf = GitInfo.get_repository_config(git)
      let ret = GitInfo.get_remote_url(conf, 'external')
      Assert Equals(ret, escape(g:giit#test#remote, '\'))
    End
  End

  Describe .get_comment_char()
    It returns a comment char
      let conf = GitInfo.get_repository_config(git)
      let ret = GitInfo.get_comment_char(conf)
      Assert Equals(ret, '#')
    End
  End

  Describe .resolve_ref()
    Context refs in a traditional directory
      It returns a content of a file in refs directory
        let exp = Git.readline(git, 'refs/heads/master')
        let ref = GitInfo.resolve_ref(git, 'refs/heads/master')
        Assert Equals(exp, ref)

        let ref = GitInfo.resolve_ref(git, 'refs/heads/develop')
        Assert NotEquals(exp, ref)
      End

      It returns a content of a file which is reffered by 'ref:'
        let exp = Git.readline(git, 'refs/remotes/origin/master')
        let ref = GitInfo.resolve_ref(git, 'refs/remotes/origin/HEAD')
        Assert Equals(exp, ref)
      End
    End

    Context refs not in a traditional directory (in packed-ref)
      It returns a content of a matched line in packed-refs file
        let fname_packed_refs = Path.join(inside, '.git', 'packed-refs')
        let saved_packed_refs = filereadable(fname_packed_refs)
              \ ? readfile(fname_packed_refs)
              \ : []
        try
          call writefile([
                \ '# pack-refs with: peeled fully-peeled ',
                \ 'aa7a5d8236c7d029f066a409928f3294a17a3805 refs/remotes/origin/foobar1',
                \ 'ba7a5d8236c7d029f066a409928f3294a17a3805 refs/remotes/origin/foobar2',
                \ 'ca7a5d8236c7d029f066a409928f3294a17a3805 refs/remotes/origin/foobar3',
                \], fname_packed_refs
                \)
          let ref = GitInfo.resolve_ref(git, 'refs/remotes/origin/foobar1')
          Assert Equals(ref, 'aa7a5d8236c7d029f066a409928f3294a17a3805')

          let ref = GitInfo.resolve_ref(git, 'refs/remotes/origin/foobar2')
          Assert Equals(ref, 'ba7a5d8236c7d029f066a409928f3294a17a3805')

          let ref = GitInfo.resolve_ref(git, 'refs/remotes/origin/foobar3')
          Assert Equals(ref, 'ca7a5d8236c7d029f066a409928f3294a17a3805')
        finally
          " Restore a content of packed-refs
          call writefile(saved_packed_refs, fname_packed_refs)
        endtry
      End
    End
  End

  Describe .get_local_hash()
    It returns a hashref of a {branch}
      let name = 'master'
      let exp = GitInfo.resolve_ref(git, 'refs/heads/' . name)

      Assert Equals(GitInfo.get_local_hash(git, name), exp)
      Assert Equals(GitInfo.get_local_hash(git, 'HEAD'), exp)
    End
  End

  Describe .get_remote_hash()
    It returns a hashref of {branch} on {remote}
      let exp = GitInfo.resolve_ref(git, 'refs/remotes/origin/master')

      Assert Equals(GitInfo.get_remote_hash(git, 'origin', 'master'), exp)
      Assert Equals(GitInfo.get_remote_hash(git, 'origin', 'HEAD'), exp)
    End
  End

  Describe .get_local_branch()
    It returns a dictionary which contains a branch name and hash
      let name = 'master'
      let hash = GitInfo.resolve_ref(git, 'refs/heads/' . name)
      let branch = GitInfo.get_local_branch(git)
      Assert Equals(branch, { 'name': name, 'hash': hash })
    End
  End

  Describe .get_remote_branch()
    It returns a dictionary which contains a branch name, hash, remote, and url
      let hash = GitInfo.resolve_ref(git, 'refs/remotes/external/master')
      let branch = GitInfo.get_remote_branch(git, 'external/master')
      Assert Equals(branch, {
            \ 'hash': hash,
            \ 'name': 'master',
            \ 'url': escape(g:giit#test#remote, '\'),
            \ 'remote': 'external',
            \})
    End
  End

  Describe .get_git_version()
    It returns a git version
      let git_version = GitInfo.get_git_version()
      Assert Match(git_version, '\d\+\.\d\+\.\d\+')
    End
  End

  Describe .get_last_commitmsg()
    It returns a last commit message
      let msg = GitInfo.get_last_commitmsg(git)
      Assert Equals(msg, ['Third', ''])
    End
  End

  Describe .count_commits_ahead_of_remote()
    It throws an exception while master does not have an upstream
      Throws /fatal: [Nn]o upstream/ GitInfo.count_commits_ahead_of_remote(git)
    End

    It returns 0 when fail_silently = 1
      Assert Equals(GitInfo.count_commits_ahead_of_remote(git, { 'fail_silently': 1 }), 0)
    End
  End

  Describe .count_commits_behind_remote()
    It throws an exception while master does not have an upstream
      Throws /fatal: [Nn]o upstream/ GitInfo.count_commits_behind_remote(git)
    End

    It returns 0 when fail_silently = 1
      Assert Equals(GitInfo.count_commits_behind_remote(git, { 'fail_silently': 1 }), 0)
    End
  End

  Describe .find_common_ancestor()
    It returns a common ancestor commit hash of two commits
      let commit = GitInfo.find_common_ancestor(git, 'master', 'develop')
      let commit2 = GitInfo.find_common_ancestor(git, 'master', commit)
      let commit3 = GitInfo.find_common_ancestor(git, 'develop', commit)
      let master = GitInfo.get_local_hash(git, 'master')
      let develop = GitInfo.get_local_hash(git, 'develop')
      Assert NotEquals(commit, master)
      Assert NotEquals(commit, develop)
      Assert Equals(commit, commit2)
      Assert Equals(commit, commit3)
    End
  End

End
